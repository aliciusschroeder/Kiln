From 40225ad3872b831b6d88a27faa9cf990ae51a509 Mon Sep 17 00:00:00 2001
From: "Leonard Q. Marcq" <marcqleonard@gmail.com>
Date: Thu, 15 May 2025 23:55:53 +0800
Subject: [PATCH 01/11] feat: add datamodel for ExtractorConfig

---
 libs/core/kiln_ai/datamodel/__init__.py       | 17 +---
 libs/core/kiln_ai/datamodel/extraction.py     | 88 +++++++++++++++++
 .../datamodel/test_extraction_model.py        | 94 +++++++++++++++++++
 3 files changed, 187 insertions(+), 12 deletions(-)
 create mode 100644 libs/core/kiln_ai/datamodel/extraction.py
 create mode 100644 libs/core/kiln_ai/datamodel/test_extraction_model.py

diff --git a/libs/core/kiln_ai/datamodel/__init__.py b/libs/core/kiln_ai/datamodel/__init__.py
index bfcea034..459dd39f 100644
--- a/libs/core/kiln_ai/datamodel/__init__.py
+++ b/libs/core/kiln_ai/datamodel/__init__.py
@@ -11,7 +11,7 @@
 
 from __future__ import annotations
 
-from kiln_ai.datamodel import dataset_split, eval, strict_mode
+from kiln_ai.datamodel import dataset_split, eval, extraction, strict_mode
 from kiln_ai.datamodel.datamodel_enums import (
     FinetuneDataStrategy,
     FineTuneStatusType,
@@ -19,13 +19,8 @@
     StructuredOutputMode,
     TaskOutputRatingType,
 )
-from kiln_ai.datamodel.dataset_split import (
-    DatasetSplit,
-    DatasetSplitDefinition,
-)
-from kiln_ai.datamodel.finetune import (
-    Finetune,
-)
+from kiln_ai.datamodel.dataset_split import DatasetSplit, DatasetSplitDefinition
+from kiln_ai.datamodel.finetune import Finetune
 from kiln_ai.datamodel.project import Project
 from kiln_ai.datamodel.prompt import BasePrompt, Prompt
 from kiln_ai.datamodel.prompt_id import (
@@ -42,15 +37,13 @@
     TaskOutput,
     TaskOutputRating,
 )
-from kiln_ai.datamodel.task_run import (
-    TaskRun,
-    Usage,
-)
+from kiln_ai.datamodel.task_run import TaskRun, Usage
 
 __all__ = [
     "strict_mode",
     "dataset_split",
     "eval",
+    "extraction",
     "Task",
     "Project",
     "TaskRun",
diff --git a/libs/core/kiln_ai/datamodel/extraction.py b/libs/core/kiln_ai/datamodel/extraction.py
new file mode 100644
index 00000000..35be7c39
--- /dev/null
+++ b/libs/core/kiln_ai/datamodel/extraction.py
@@ -0,0 +1,88 @@
+import json
+from enum import Enum
+from typing import Any, List
+
+from pydantic import BaseModel, Field, ValidationError, model_validator
+from typing_extensions import Self
+
+from kiln_ai.datamodel.basemodel import NAME_FIELD, KilnBaseModel
+
+
+def format_properties_errors(e: ValidationError) -> str:
+    errors: List[str] = []
+    for error in e.errors():
+        loc = error["loc"][0]
+        msg = error["msg"]
+        errors.append(f"{loc}: {msg}.")
+    return "\n".join(errors)
+
+
+class OutputFormat(str, Enum):
+    TEXT = "text/plain"
+    MARKDOWN = "text/markdown"
+
+
+class ExtractorType(str, Enum):
+    gemini = "gemini"
+
+
+class Kind(str, Enum):
+    DOCUMENT = "document"
+    IMAGE = "image"
+    VIDEO = "video"
+    AUDIO = "audio"
+
+
+class GeminiProperties(BaseModel):
+    prompt_for_kind: dict[Kind, str] = Field(
+        description="A dictionary of prompts for each kind of content to extract.",
+    )
+
+    model_name: str = Field(
+        description="The name of the model to use for this extractor config. ",
+    )
+
+
+class ExtractorConfig(KilnBaseModel):
+    name: str = NAME_FIELD
+
+    output_format: OutputFormat = Field(
+        default=OutputFormat.MARKDOWN,
+        description="The format to use for the output.",
+    )
+    passthrough_mimetypes: list[OutputFormat] = Field(
+        default_factory=list,
+        description="If the mimetype is in this list, the extractor will not be used and the text content of the file will be returned as is.",
+    )
+    extractor_type: ExtractorType = Field(
+        default=ExtractorType.gemini,
+        description="This is used to determine the type of extractor to use.",
+    )
+    properties: dict[str, Any] = Field(
+        default={},
+        description="Properties to be used to execute the extractor config. This is config_type specific and should serialize to a json dict.",
+    )
+
+    @model_validator(mode="after")
+    def validate_properties(self) -> Self:
+        if self.extractor_type == ExtractorType.gemini:
+            # This will raise an error if the properties are invalid
+            try:
+                GeminiProperties(**self.properties)
+            except ValidationError as e:
+                raise ValueError(format_properties_errors(e))
+            return self
+        else:
+            raise ValueError(f"Invalid extractor type: {self.extractor_type}")
+
+    @model_validator(mode="after")
+    def validate_json_serializable(self) -> Self:
+        try:
+            # This will raise a TypeError if the dict contains non-JSON-serializable objects
+            json.dumps(self.properties)
+        except TypeError as e:
+            raise ValueError(f"Properties must be JSON serializable: {str(e)}")
+        return self
+
+    def gemini_properties(self) -> GeminiProperties:
+        return GeminiProperties(**self.properties)
diff --git a/libs/core/kiln_ai/datamodel/test_extraction_model.py b/libs/core/kiln_ai/datamodel/test_extraction_model.py
new file mode 100644
index 00000000..9986a9ef
--- /dev/null
+++ b/libs/core/kiln_ai/datamodel/test_extraction_model.py
@@ -0,0 +1,94 @@
+import pytest
+
+from kiln_ai.datamodel.extraction import ExtractorConfig, ExtractorType
+
+
+@pytest.fixture
+def valid_extractor_config_data():
+    return {
+        "name": "Test Extractor Config",
+        "extractor_type": ExtractorType.gemini,
+        "properties": {
+            "prompt_for_kind": {
+                "document": "Transcribe the document.",
+                "audio": "Transcribe the audio.",
+                "video": "Transcribe the video.",
+                "image": "Describe the image.",
+            },
+            "model_name": "gemini-2.0-flash",
+        },
+    }
+
+
+@pytest.fixture
+def valid_extractor_config(valid_extractor_config_data):
+    return ExtractorConfig(**valid_extractor_config_data)
+
+
+def test_extractor_config_valid(valid_extractor_config):
+    assert valid_extractor_config.name == "Test Extractor Config"
+    assert valid_extractor_config.extractor_type == ExtractorType.gemini
+    assert valid_extractor_config.properties["prompt_for_kind"] == {
+        "document": "Transcribe the document.",
+        "audio": "Transcribe the audio.",
+        "video": "Transcribe the video.",
+        "image": "Describe the image.",
+    }
+    assert valid_extractor_config.properties["model_name"] == "gemini-2.0-flash"
+
+
+def test_extractor_config_empty_properties(valid_extractor_config):
+    with pytest.raises(ValueError, match="prompt_for_kind: Field required."):
+        valid_extractor_config.properties = {}
+
+
+def test_extractor_config_missing_model_name(
+    valid_extractor_config, valid_extractor_config_data
+):
+    with pytest.raises(ValueError, match="model_name: Field required."):
+        valid_extractor_config.properties = {
+            "prompt_for_kind": valid_extractor_config_data["properties"][
+                "prompt_for_kind"
+            ],
+        }
+
+
+def test_extractor_config_missing_prompt_for_kind(valid_extractor_config):
+    with pytest.raises(
+        ValueError,
+        match="prompt_for_kind: Field required.",
+    ):
+        valid_extractor_config.properties = {"model_name": "gemini-2.0-flash"}
+
+
+def test_extractor_config_invalid_json(
+    valid_extractor_config, valid_extractor_config_data
+):
+    class InvalidClass:
+        pass
+
+    with pytest.raises(ValueError, match="Properties must be JSON serializable"):
+        valid_extractor_config.properties = {
+            "prompt_for_kind": valid_extractor_config_data["properties"][
+                "prompt_for_kind"
+            ],
+            "model_name": "gemini-2.0-flash",
+            "invalid_key": InvalidClass(),
+        }
+
+
+def test_extractor_config_invalid_prompt_for_kind(valid_extractor_config):
+    with pytest.raises(
+        ValueError,
+        match="prompt_for_kind: Input should be a valid dictionary.",
+    ):
+        valid_extractor_config.properties = {
+            "prompt_for_kind": "not a dict",
+            "model_name": "gemini-2.0-flash",
+        }
+
+
+def test_extractor_config_invalid_config_type(valid_extractor_config):
+    # Create an invalid config type using string
+    with pytest.raises(ValueError):
+        valid_extractor_config.extractor_type = "invalid_type"

From 3a73a6584bbcc610c1420d421ead56749090018b Mon Sep 17 00:00:00 2001
From: "Leonard Q. Marcq" <marcqleonard@gmail.com>
Date: Thu, 15 May 2025 23:57:17 +0800
Subject: [PATCH 02/11] refactor: use ExtractorConfig in extractors, rename
 extractors package into extraction, update tests

---
 libs/core/kiln_ai/adapters/__init__.py        |   2 +
 .../{extractors => extraction}/__init__.py    |   3 +-
 .../base_extractor.py                         |  34 +----
 .../gemini_extractor.py                       |  50 ++-----
 .../kiln_ai/adapters/extraction/registry.py   |  15 ++
 .../test_base_extractor.py                    | 140 ++++++++++++------
 .../test_gemini_extractor.py                  |  91 ++++++------
 .../adapters/extraction/test_registry.py      |  14 ++
 8 files changed, 192 insertions(+), 157 deletions(-)
 rename libs/core/kiln_ai/adapters/{extractors => extraction}/__init__.py (76%)
 rename libs/core/kiln_ai/adapters/{extractors => extraction}/base_extractor.py (70%)
 rename libs/core/kiln_ai/adapters/{extractors => extraction}/gemini_extractor.py (68%)
 create mode 100644 libs/core/kiln_ai/adapters/extraction/registry.py
 rename libs/core/kiln_ai/adapters/{extractors => extraction}/test_base_extractor.py (59%)
 rename libs/core/kiln_ai/adapters/{extractors => extraction}/test_gemini_extractor.py (74%)
 create mode 100644 libs/core/kiln_ai/adapters/extraction/test_registry.py

diff --git a/libs/core/kiln_ai/adapters/__init__.py b/libs/core/kiln_ai/adapters/__init__.py
index b69056d2..752d1b96 100644
--- a/libs/core/kiln_ai/adapters/__init__.py
+++ b/libs/core/kiln_ai/adapters/__init__.py
@@ -19,6 +19,7 @@
 from . import (
     data_gen,
     eval,
+    extraction,
     fine_tune,
     ml_model_list,
     model_adapters,
@@ -34,4 +35,5 @@
     "prompt_builders",
     "repair",
     "eval",
+    "extraction",
 ]
diff --git a/libs/core/kiln_ai/adapters/extractors/__init__.py b/libs/core/kiln_ai/adapters/extraction/__init__.py
similarity index 76%
rename from libs/core/kiln_ai/adapters/extractors/__init__.py
rename to libs/core/kiln_ai/adapters/extraction/__init__.py
index 9d321422..a5408844 100644
--- a/libs/core/kiln_ai/adapters/extractors/__init__.py
+++ b/libs/core/kiln_ai/adapters/extraction/__init__.py
@@ -5,9 +5,10 @@
 using different extraction methods.
 """
 
-from . import base_extractor, gemini_extractor
+from . import base_extractor, gemini_extractor, registry
 
 __all__ = [
     "base_extractor",
     "gemini_extractor",
+    "registry",
 ]
diff --git a/libs/core/kiln_ai/adapters/extractors/base_extractor.py b/libs/core/kiln_ai/adapters/extraction/base_extractor.py
similarity index 70%
rename from libs/core/kiln_ai/adapters/extractors/base_extractor.py
rename to libs/core/kiln_ai/adapters/extraction/base_extractor.py
index 12411a73..9f624cf2 100644
--- a/libs/core/kiln_ai/adapters/extractors/base_extractor.py
+++ b/libs/core/kiln_ai/adapters/extraction/base_extractor.py
@@ -2,32 +2,12 @@
 import mimetypes
 import pathlib
 from abc import ABC, abstractmethod
-from enum import Enum
 
 from pydantic import BaseModel, Field
 
-logger = logging.getLogger(__name__)
-
-
-class ExtractionFormat(str, Enum):
-    TEXT = "text/plain"
-    MARKDOWN = "text/markdown"
+from kiln_ai.datamodel.extraction import ExtractorConfig, OutputFormat
 
-
-class BaseExtractorConfig(BaseModel):
-    """
-    Base class for all extractor configs.
-    """
-
-    passthrough_mimetypes: list[ExtractionFormat] = Field(
-        default_factory=list,
-        description="If the mimetype is in this list, the extractor will not be used and the text content of the file will be returned as is.",
-    )
-
-    output_format: ExtractionFormat = Field(
-        default=ExtractionFormat.MARKDOWN,
-        description="The format to use for the output.",
-    )
+logger = logging.getLogger(__name__)
 
 
 # TODO: take in the file/document datamodel instead once we have it
@@ -44,7 +24,7 @@ class ExtractionOutput(BaseModel):
     is_passthrough: bool = Field(
         default=False, description="Whether the extractor returned the file as is."
     )
-    content_format: ExtractionFormat = Field(
+    content_format: OutputFormat = Field(
         description="The format of the extracted data."
     )
     content: str = Field(description="The extracted data.")
@@ -57,8 +37,8 @@ class BaseExtractor(ABC):
     Should be subclassed by each extractor.
     """
 
-    def __init__(self, config: BaseExtractorConfig):
-        self.config = config
+    def __init__(self, extractor_config: ExtractorConfig):
+        self.extractor_config = extractor_config
 
     @abstractmethod
     def _extract(self, file_info: FileInfoInternal) -> ExtractionOutput:
@@ -80,7 +60,7 @@ def extract(
                 return ExtractionOutput(
                     is_passthrough=True,
                     content=pathlib.Path(file_info.path).read_text(encoding="utf-8"),
-                    content_format=self.config.output_format,
+                    content_format=self.extractor_config.output_format,
                 )
 
             return self._extract(
@@ -94,5 +74,5 @@ def extract(
 
     def _should_passthrough(self, mime_type: str) -> bool:
         return mime_type.lower() in {
-            mt.lower() for mt in self.config.passthrough_mimetypes
+            mt.lower() for mt in self.extractor_config.passthrough_mimetypes
         }
diff --git a/libs/core/kiln_ai/adapters/extractors/gemini_extractor.py b/libs/core/kiln_ai/adapters/extraction/gemini_extractor.py
similarity index 68%
rename from libs/core/kiln_ai/adapters/extractors/gemini_extractor.py
rename to libs/core/kiln_ai/adapters/extraction/gemini_extractor.py
index 703229a7..e13c4478 100644
--- a/libs/core/kiln_ai/adapters/extractors/gemini_extractor.py
+++ b/libs/core/kiln_ai/adapters/extraction/gemini_extractor.py
@@ -1,25 +1,14 @@
 import pathlib
-from enum import Enum
 
 from google import genai
 from google.genai import types
-from pydantic import Field
 
-from kiln_ai.adapters.extractors.base_extractor import (
+from kiln_ai.adapters.extraction.base_extractor import (
     BaseExtractor,
-    BaseExtractorConfig,
-    ExtractionFormat,
     ExtractionOutput,
     FileInfoInternal,
 )
-
-
-class Kind(Enum):
-    DOCUMENT = "document"
-    IMAGE = "image"
-    VIDEO = "video"
-    AUDIO = "audio"
-
+from kiln_ai.datamodel.extraction import ExtractorConfig, ExtractorType, Kind
 
 # docs list out supported formats:
 # - https://ai.google.dev/gemini-api/docs/document-processing#supported-formats
@@ -72,29 +61,16 @@ class Kind(Enum):
 }
 
 
-class GeminiExtractorConfig(BaseExtractorConfig):
-    prompt_for_kind: dict[Kind, str] = Field(
-        default_factory=dict,
-        description="A dictionary of prompts for each kind of file.",
-    )
-    model_id: str = Field(
-        description="The model to use for the extractor.",
-        examples=["gemini-2.0-flash"],
-    )
-    output_format: ExtractionFormat = Field(
-        default=ExtractionFormat.MARKDOWN,
-        description="The format to use for the output.",
-    )
-
-
 class GeminiExtractor(BaseExtractor):
-    def __init__(self, gemini_client: genai.Client, config: GeminiExtractorConfig):
-        super().__init__(config)
-        self.gemini_client = gemini_client
+    def __init__(self, gemini_client: genai.Client, extractor_config: ExtractorConfig):
+        if extractor_config.extractor_type != ExtractorType.gemini:
+            raise ValueError(
+                f"GeminiExtractor must be initialized with a gemini extractor_type config. Got {extractor_config.extractor_type}"
+            )
 
-        # TODO: the hack below will go away once we have ExtractorConfig as a dict anyway
-        # hack to access the concrete config subclass here without failing type checking
-        self.config = config
+        super().__init__(extractor_config)
+        self.gemini_client = gemini_client
+        self.gemini_config = extractor_config.gemini_properties()
 
     def _get_kind_from_mime_type(self, mime_type: str) -> Kind | None:
         for kind, mime_types in MIME_TYPES_SUPPORTED.items():
@@ -107,12 +83,12 @@ def _extract(self, file_info: FileInfoInternal) -> ExtractionOutput:
         if kind is None:
             raise ValueError(f"Unsupported MIME type: {file_info.mime_type}")
 
-        prompt = self.config.prompt_for_kind.get(kind)
+        prompt = self.gemini_config.prompt_for_kind.get(kind)
         if prompt is None:
             raise ValueError(f"No prompt found for kind: {kind}")
 
         response = self.gemini_client.models.generate_content(
-            model=self.config.model_id,
+            model=self.gemini_config.model_name,
             contents=[
                 types.Part.from_bytes(
                     data=pathlib.Path(file_info.path).read_bytes(),
@@ -128,5 +104,5 @@ def _extract(self, file_info: FileInfoInternal) -> ExtractionOutput:
         return ExtractionOutput(
             is_passthrough=False,
             content=response.text,
-            content_format=self.config.output_format,
+            content_format=self.extractor_config.output_format,
         )
diff --git a/libs/core/kiln_ai/adapters/extraction/registry.py b/libs/core/kiln_ai/adapters/extraction/registry.py
new file mode 100644
index 00000000..7d7a52fc
--- /dev/null
+++ b/libs/core/kiln_ai/adapters/extraction/registry.py
@@ -0,0 +1,15 @@
+from kiln_ai.adapters.extraction.base_extractor import BaseExtractor
+from kiln_ai.adapters.extraction.gemini_extractor import GeminiExtractor
+from kiln_ai.datamodel.extraction import ExtractorType
+from kiln_ai.utils.exhaustive_error import raise_exhaustive_enum_error
+
+
+def extractor_adapter_from_type(
+    extractor_config_type: ExtractorType,
+) -> type[BaseExtractor]:
+    match extractor_config_type:
+        case ExtractorType.gemini:
+            return GeminiExtractor
+        case _:
+            # type checking will catch missing cases
+            raise_exhaustive_enum_error(extractor_config_type)
diff --git a/libs/core/kiln_ai/adapters/extractors/test_base_extractor.py b/libs/core/kiln_ai/adapters/extraction/test_base_extractor.py
similarity index 59%
rename from libs/core/kiln_ai/adapters/extractors/test_base_extractor.py
rename to libs/core/kiln_ai/adapters/extraction/test_base_extractor.py
index ccc66e87..1767bdf7 100644
--- a/libs/core/kiln_ai/adapters/extractors/test_base_extractor.py
+++ b/libs/core/kiln_ai/adapters/extraction/test_base_extractor.py
@@ -1,15 +1,16 @@
+from typing import Any
 from unittest.mock import patch
 
 import pytest
 
-from kiln_ai.adapters.extractors.base_extractor import (
+from kiln_ai.adapters.extraction.base_extractor import (
     BaseExtractor,
-    BaseExtractorConfig,
-    ExtractionFormat,
     ExtractionOutput,
     FileInfo,
     FileInfoInternal,
+    OutputFormat,
 )
+from kiln_ai.datamodel.extraction import ExtractorConfig
 
 
 class MockBaseExtractor(BaseExtractor):
@@ -17,33 +18,54 @@ def _extract(self, file_info: FileInfoInternal) -> ExtractionOutput:
         return ExtractionOutput(
             is_passthrough=False,
             content="mock concrete extractor output",
-            content_format=ExtractionFormat.MARKDOWN,
+            content_format=OutputFormat.MARKDOWN,
         )
 
 
 @pytest.fixture
-def mock_extractor():
-    return MockBaseExtractor(BaseExtractorConfig())
+def mock_gemini_properties():
+    return {
+        "prompt_for_kind": {
+            "document": "mock prompt for document",
+            "image": "mock prompt for image",
+            "video": "mock prompt for video",
+            "audio": "mock prompt for audio",
+        },
+        "model_name": "mock",
+    }
+
+
+@pytest.fixture
+def mock_extractor(mock_gemini_properties):
+    return MockBaseExtractor(
+        ExtractorConfig(
+            name="mock",
+            output_format=OutputFormat.MARKDOWN,
+            properties=mock_gemini_properties,
+        )
+    )
 
 
 def mock_extractor_with_passthroughs(
-    mimetypes: list[ExtractionFormat], output_format: ExtractionFormat
+    properties: dict[str, Any],
+    mimetypes: list[OutputFormat],
+    output_format: OutputFormat,
 ):
     return MockBaseExtractor(
-        BaseExtractorConfig(
-            passthrough_mimetypes=mimetypes, output_format=output_format
+        ExtractorConfig(
+            name="mock",
+            passthrough_mimetypes=mimetypes,
+            output_format=output_format,
+            properties=properties,
         )
     )
 
 
-def test_should_passthrough():
-    extractor = MockBaseExtractor(
-        BaseExtractorConfig(
-            passthrough_mimetypes=[
-                ExtractionFormat.TEXT,
-                ExtractionFormat.MARKDOWN,
-            ]
-        )
+def test_should_passthrough(mock_gemini_properties):
+    extractor = mock_extractor_with_passthroughs(
+        mock_gemini_properties,
+        [OutputFormat.TEXT, OutputFormat.MARKDOWN],
+        OutputFormat.TEXT,
     )
 
     # should passthrough
@@ -57,14 +79,16 @@ def test_should_passthrough():
     assert not extractor._should_passthrough("image/jpeg")
 
 
-def test_extract_passthrough():
+def test_extract_passthrough(mock_gemini_properties):
     """
     Tests that when a file's MIME type is configured for passthrough, the extractor skips
     the concrete extraction method and returns the file's contents directly with the
     correct passthrough output format.
     """
     extractor = mock_extractor_with_passthroughs(
-        [ExtractionFormat.TEXT, ExtractionFormat.MARKDOWN], ExtractionFormat.TEXT
+        mock_gemini_properties,
+        [OutputFormat.TEXT, OutputFormat.MARKDOWN],
+        OutputFormat.TEXT,
     )
     with (
         patch.object(
@@ -73,7 +97,7 @@ def test_extract_passthrough():
             return_value=ExtractionOutput(
                 is_passthrough=False,
                 content="mock concrete extractor output",
-                content_format=ExtractionFormat.TEXT,
+                content_format=OutputFormat.TEXT,
             ),
         ) as mock_extract,
         patch(
@@ -93,19 +117,21 @@ def test_extract_passthrough():
         # Verify correct passthrough result
         assert result.is_passthrough
         assert result.content == "test content"
-        assert result.content_format == ExtractionFormat.TEXT
+        assert result.content_format == OutputFormat.TEXT
 
 
 @pytest.mark.parametrize(
     "output_format",
     [
-        ExtractionFormat.TEXT,
-        ExtractionFormat.MARKDOWN,
+        "text/plain",
+        "text/markdown",
     ],
 )
-def test_extract_passthrough_output_format(output_format: ExtractionFormat):
+def test_extract_passthrough_output_format(mock_gemini_properties, output_format):
     extractor = mock_extractor_with_passthroughs(
-        [ExtractionFormat.TEXT, ExtractionFormat.MARKDOWN], output_format
+        mock_gemini_properties,
+        [OutputFormat.TEXT, OutputFormat.MARKDOWN],
+        output_format,
     )
     with (
         patch.object(
@@ -140,23 +166,21 @@ def test_extract_passthrough_output_format(output_format: ExtractionFormat):
 @pytest.mark.parametrize(
     "path, mime_type, output_format",
     [
-        ("test.mp3", "audio/mpeg", ExtractionFormat.TEXT),
-        ("test.png", "image/png", ExtractionFormat.TEXT),
-        ("test.pdf", "application/pdf", ExtractionFormat.TEXT),
-        ("test.txt", "text/plain", ExtractionFormat.MARKDOWN),
-        ("test.txt", "text/markdown", ExtractionFormat.MARKDOWN),
-        ("test.html", "text/html", ExtractionFormat.MARKDOWN),
-        ("test.csv", "text/csv", ExtractionFormat.MARKDOWN),
+        ("test.mp3", "audio/mpeg", OutputFormat.TEXT),
+        ("test.png", "image/png", OutputFormat.TEXT),
+        ("test.pdf", "application/pdf", OutputFormat.TEXT),
+        ("test.txt", "text/plain", OutputFormat.MARKDOWN),
+        ("test.txt", "text/markdown", OutputFormat.MARKDOWN),
+        ("test.html", "text/html", OutputFormat.MARKDOWN),
+        ("test.csv", "text/csv", OutputFormat.MARKDOWN),
     ],
 )
 def test_extract_non_passthrough(
-    path: str, mime_type: str, output_format: ExtractionFormat
+    mock_extractor, path: str, mime_type: str, output_format: OutputFormat
 ):
-    extractor = MockBaseExtractor(BaseExtractorConfig(output_format=output_format))
-
     with (
         patch.object(
-            extractor,
+            mock_extractor,
             "_extract",
             return_value=ExtractionOutput(
                 is_passthrough=False,
@@ -170,7 +194,7 @@ def test_extract_non_passthrough(
         ),
     ):
         # first we call the base class extract method
-        result = extractor.extract(file_info=FileInfo(path=path))
+        result = mock_extractor.extract(file_info=FileInfo(path=path))
 
         # then we call the subclass _extract method and add validated mime_type
         mock_extract.assert_called_once_with(
@@ -185,13 +209,19 @@ def test_extract_non_passthrough(
 @pytest.mark.parametrize(
     "passthrough_mimetypes",
     [
-        ["text/plain"],
-        ["text/markdown"],
-        ["text/plain", "text/markdown"],
+        [OutputFormat.TEXT],
+        [OutputFormat.MARKDOWN],
+        [OutputFormat.TEXT, OutputFormat.MARKDOWN],
     ],
 )
-def test_validate_passthrough_mime_types(passthrough_mimetypes: list[ExtractionFormat]):
-    config = BaseExtractorConfig(passthrough_mimetypes=passthrough_mimetypes)
+def test_validate_passthrough_mime_types(
+    mock_gemini_properties, passthrough_mimetypes: list[OutputFormat]
+):
+    config = ExtractorConfig(
+        name="mock",
+        passthrough_mimetypes=passthrough_mimetypes,
+        properties=mock_gemini_properties,
+    )
     assert config.passthrough_mimetypes == passthrough_mimetypes
 
 
@@ -205,15 +235,22 @@ def test_validate_passthrough_mime_types(passthrough_mimetypes: list[ExtractionF
     ],
 )
 def test_validate_passthrough_mime_types_failure(
-    passthrough_mimetypes,
+    mock_gemini_properties, passthrough_mimetypes: list[OutputFormat]
 ):
     with pytest.raises(ValueError):
-        BaseExtractorConfig(passthrough_mimetypes=passthrough_mimetypes)
+        ExtractorConfig(
+            name="mock",
+            passthrough_mimetypes=passthrough_mimetypes,
+            properties=mock_gemini_properties,
+        )
 
 
-def test_default_output_format():
-    config = BaseExtractorConfig()
-    assert config.output_format == ExtractionFormat.MARKDOWN
+def test_default_output_format(mock_gemini_properties):
+    config = ExtractorConfig(
+        name="mock",
+        properties=mock_gemini_properties,
+    )
+    assert config.output_format == OutputFormat.MARKDOWN
 
 
 def test_extract_failure_from_concrete_extractor(mock_extractor):
@@ -226,8 +263,13 @@ def test_extract_failure_from_concrete_extractor(mock_extractor):
             mock_extractor.extract(file_info=FileInfo(path="test.txt"))
 
 
-def test_extract_failure_from_mime_type_guess():
-    extractor = MockBaseExtractor(BaseExtractorConfig())
+def test_extract_failure_from_mime_type_guess(mock_gemini_properties):
+    extractor = MockBaseExtractor(
+        ExtractorConfig(
+            name="mock",
+            properties=mock_gemini_properties,
+        )
+    )
     with patch(
         "mimetypes.guess_type",
         return_value=(None, None),
diff --git a/libs/core/kiln_ai/adapters/extractors/test_gemini_extractor.py b/libs/core/kiln_ai/adapters/extraction/test_gemini_extractor.py
similarity index 74%
rename from libs/core/kiln_ai/adapters/extractors/test_gemini_extractor.py
rename to libs/core/kiln_ai/adapters/extraction/test_gemini_extractor.py
index 07ef565e..42eb9be4 100644
--- a/libs/core/kiln_ai/adapters/extractors/test_gemini_extractor.py
+++ b/libs/core/kiln_ai/adapters/extraction/test_gemini_extractor.py
@@ -5,24 +5,24 @@
 from google import genai
 from google.genai import types
 
-from kiln_ai.adapters.extractors.base_extractor import (
-    ExtractionFormat,
+from kiln_ai.adapters.extraction.base_extractor import (
     ExtractionOutput,
     FileInfo,
     FileInfoInternal,
+    OutputFormat,
 )
-from kiln_ai.adapters.extractors.gemini_extractor import (
+from kiln_ai.adapters.extraction.gemini_extractor import (
+    ExtractorConfig,
     GeminiExtractor,
-    GeminiExtractorConfig,
     Kind,
 )
 from kiln_ai.utils.config import Config
 
-PROMPTS_FOR_KIND = {
-    Kind.DOCUMENT: "prompt for documents",
-    Kind.IMAGE: "prompt for images",
-    Kind.VIDEO: "prompt for videos",
-    Kind.AUDIO: "prompt for audio",
+PROMPTS_FOR_KIND: dict[str, str] = {
+    "document": "prompt for documents",
+    "image": "prompt for images",
+    "video": "prompt for videos",
+    "audio": "prompt for audio",
 }
 
 
@@ -35,9 +35,12 @@ def mock_gemini_client():
 def mock_gemini_extractor(mock_gemini_client):
     return GeminiExtractor(
         mock_gemini_client,
-        GeminiExtractorConfig(
-            prompt_for_kind=PROMPTS_FOR_KIND,
-            model_id="fake-model",
+        ExtractorConfig(
+            name="mock",
+            properties={
+                "prompt_for_kind": PROMPTS_FOR_KIND,
+                "model_name": "fake-model",
+            },
         ),
     )
 
@@ -119,7 +122,7 @@ def test_extract_success(mock_gemini_extractor):
         ) == ExtractionOutput(
             is_passthrough=False,
             content="extracted content",
-            content_format=ExtractionFormat.MARKDOWN,
+            content_format=OutputFormat.MARKDOWN,
         )
 
         # check the gemini client was called with the correct arguments
@@ -208,20 +211,22 @@ def test_extract_failure_unsupported_mime_type(mock_gemini_extractor):
 SUPPORTED_MODELS = ["gemini-2.0-flash"]
 
 
-def paid_gemini_extractor(model_id: str):
+def paid_gemini_extractor(model_name: str):
     return GeminiExtractor(
-        config=GeminiExtractorConfig(
-            model_id=model_id,
-            output_format=ExtractionFormat.MARKDOWN,
-            prompt_for_kind={
-                Kind.DOCUMENT: "Return a short paragraph summarizing the document. Start your answer with the word 'Document summary:'.",
-                Kind.IMAGE: "Return a short paragraph summarizing the image. Start your answer with the word 'Image summary:'.",
-                Kind.VIDEO: "Return a short paragraph summarizing the video. Start your answer with the word 'Video summary:'.",
-                Kind.AUDIO: "Return a short paragraph summarizing the audio. Start your answer with the word 'Audio summary:'.",
+        extractor_config=ExtractorConfig(
+            name="paid-gemini",
+            properties={
+                "model_name": model_name,
+                "prompt_for_kind": {
+                    "document": "Return a short paragraph summarizing the document. Start your answer with the word 'Document summary:'.",
+                    "image": "Return a short paragraph summarizing the image. Start your answer with the word 'Image summary:'.",
+                    "video": "Return a short paragraph summarizing the video. Start your answer with the word 'Video summary:'.",
+                    "audio": "Return a short paragraph summarizing the audio. Start your answer with the word 'Audio summary:'.",
+                },
             },
             passthrough_mimetypes=[
-                ExtractionFormat.TEXT,
-                ExtractionFormat.MARKDOWN,
+                OutputFormat.TEXT,
+                OutputFormat.MARKDOWN,
             ],
         ),
         gemini_client=genai.Client(
@@ -231,61 +236,61 @@ def paid_gemini_extractor(model_id: str):
 
 
 @pytest.mark.paid
-@pytest.mark.parametrize("model_id", SUPPORTED_MODELS)
-def test_extract_document(model_id, test_data_dir):
-    extractor = paid_gemini_extractor(model_id=model_id)
+@pytest.mark.parametrize("model_name", SUPPORTED_MODELS)
+def test_extract_document(model_name, test_data_dir):
+    extractor = paid_gemini_extractor(model_name=model_name)
     output = extractor.extract(
         file_info=FileInfo(path=str(test_data_dir / "1706.03762v7.pdf")),
     )
     assert not output.is_passthrough
-    assert output.content_format == ExtractionFormat.MARKDOWN
+    assert output.content_format == OutputFormat.MARKDOWN
     assert "Document summary:" in output.content
 
 
 @pytest.mark.paid
-@pytest.mark.parametrize("model_id", SUPPORTED_MODELS)
-def test_extract_image(model_id, test_data_dir):
-    extractor = paid_gemini_extractor(model_id=model_id)
+@pytest.mark.parametrize("model_name", SUPPORTED_MODELS)
+def test_extract_image(model_name, test_data_dir):
+    extractor = paid_gemini_extractor(model_name=model_name)
     output = extractor.extract(
         file_info=FileInfo(path=str(test_data_dir / "kodim23.png")),
     )
     assert not output.is_passthrough
-    assert output.content_format == ExtractionFormat.MARKDOWN
+    assert output.content_format == OutputFormat.MARKDOWN
     assert "Image summary:" in output.content
 
 
 @pytest.mark.paid
-@pytest.mark.parametrize("model_id", SUPPORTED_MODELS)
-def test_extract_video(model_id, test_data_dir):
-    extractor = paid_gemini_extractor(model_id=model_id)
+@pytest.mark.parametrize("model_name", SUPPORTED_MODELS)
+def test_extract_video(model_name, test_data_dir):
+    extractor = paid_gemini_extractor(model_name=model_name)
     output = extractor.extract(
         file_info=FileInfo(path=str(test_data_dir / "big_buck_bunny_sample.mp4")),
     )
     assert not output.is_passthrough
-    assert output.content_format == ExtractionFormat.MARKDOWN
+    assert output.content_format == OutputFormat.MARKDOWN
     assert "Video summary:" in output.content
 
 
 @pytest.mark.paid
-@pytest.mark.parametrize("model_id", SUPPORTED_MODELS)
-def test_extract_audio(model_id, test_data_dir):
-    extractor = paid_gemini_extractor(model_id=model_id)
+@pytest.mark.parametrize("model_name", SUPPORTED_MODELS)
+def test_extract_audio(model_name, test_data_dir):
+    extractor = paid_gemini_extractor(model_name=model_name)
     output = extractor.extract(
         file_info=FileInfo(path=str(test_data_dir / "poacher.ogg")),
     )
     assert not output.is_passthrough
-    assert output.content_format == ExtractionFormat.MARKDOWN
+    assert output.content_format == OutputFormat.MARKDOWN
     assert "Audio summary:" in output.content
 
 
 @pytest.mark.paid
-@pytest.mark.parametrize("model_id", SUPPORTED_MODELS)
-def test_provider_bad_request(tmp_path, model_id):
+@pytest.mark.parametrize("model_name", SUPPORTED_MODELS)
+def test_provider_bad_request(tmp_path, model_name):
     # write corrupted PDF file to temp files
     temp_file = tmp_path / "corrupted_file.pdf"
     temp_file.write_bytes(b"invalid file")
 
-    extractor = paid_gemini_extractor(model_id=model_id)
+    extractor = paid_gemini_extractor(model_name=model_name)
 
     with pytest.raises(ValueError, match="Error extracting .*corrupted_file.pdf: "):
         extractor.extract(
diff --git a/libs/core/kiln_ai/adapters/extraction/test_registry.py b/libs/core/kiln_ai/adapters/extraction/test_registry.py
new file mode 100644
index 00000000..5d1d2494
--- /dev/null
+++ b/libs/core/kiln_ai/adapters/extraction/test_registry.py
@@ -0,0 +1,14 @@
+import pytest
+
+from kiln_ai.adapters.extraction.gemini_extractor import GeminiExtractor
+from kiln_ai.adapters.extraction.registry import extractor_adapter_from_type
+from kiln_ai.datamodel.extraction import ExtractorType
+
+
+def test_extractor_adapter_from_type():
+    assert extractor_adapter_from_type(ExtractorType.gemini) == GeminiExtractor
+
+
+def test_extractor_adapter_from_type_invalid():
+    with pytest.raises(ValueError):
+        extractor_adapter_from_type("invalid-type")  # type: ignore

From de5d8a6f19cb76ae96ae199eb274578c32911411 Mon Sep 17 00:00:00 2001
From: "Leonard Q. Marcq" <marcqleonard@gmail.com>
Date: Fri, 16 May 2025 00:55:51 +0800
Subject: [PATCH 03/11] fix: better validation of prompt_for_kind, test for
 kind coercion to address coderabbit cr

---
 libs/core/kiln_ai/datamodel/extraction.py     |  17 ++-
 .../datamodel/test_extraction_model.py        | 101 +++++++++++++++++-
 2 files changed, 114 insertions(+), 4 deletions(-)

diff --git a/libs/core/kiln_ai/datamodel/extraction.py b/libs/core/kiln_ai/datamodel/extraction.py
index 35be7c39..fdff96dd 100644
--- a/libs/core/kiln_ai/datamodel/extraction.py
+++ b/libs/core/kiln_ai/datamodel/extraction.py
@@ -11,9 +11,13 @@
 def format_properties_errors(e: ValidationError) -> str:
     errors: List[str] = []
     for error in e.errors():
-        loc = error["loc"][0]
-        msg = error["msg"]
-        errors.append(f"{loc}: {msg}.")
+        if "loc" in error and len(error["loc"]) > 0:
+            loc = error["loc"][0]
+            msg = error["msg"]
+            errors.append(f"{loc}: {msg}.")
+        else:
+            # ValueError raised from custom validator does not have a loc
+            errors.append(f"{error['msg']}.")
     return "\n".join(errors)
 
 
@@ -42,6 +46,13 @@ class GeminiProperties(BaseModel):
         description="The name of the model to use for this extractor config. ",
     )
 
+    @model_validator(mode="after")
+    def validate_model_name(self) -> Self:
+        for kind in Kind:
+            if kind not in self.prompt_for_kind:
+                raise ValueError(f"Prompt for kind {kind.value} is required.")
+        return self
+
 
 class ExtractorConfig(KilnBaseModel):
     name: str = NAME_FIELD
diff --git a/libs/core/kiln_ai/datamodel/test_extraction_model.py b/libs/core/kiln_ai/datamodel/test_extraction_model.py
index 9986a9ef..2e1fb445 100644
--- a/libs/core/kiln_ai/datamodel/test_extraction_model.py
+++ b/libs/core/kiln_ai/datamodel/test_extraction_model.py
@@ -1,6 +1,13 @@
 import pytest
+from pydantic import BaseModel, Field, ValidationError, model_validator
+from typing_extensions import Self
 
-from kiln_ai.datamodel.extraction import ExtractorConfig, ExtractorType
+from kiln_ai.datamodel.extraction import (
+    ExtractorConfig,
+    ExtractorType,
+    Kind,
+    format_properties_errors,
+)
 
 
 @pytest.fixture
@@ -25,6 +32,17 @@ def valid_extractor_config(valid_extractor_config_data):
     return ExtractorConfig(**valid_extractor_config_data)
 
 
+def test_extractor_config_kind_coercion(valid_extractor_config):
+    # check that the string values are coerced to the correct kind
+    gemini_config = valid_extractor_config.gemini_properties()
+    assert (
+        gemini_config.prompt_for_kind.get(Kind.DOCUMENT) == "Transcribe the document."
+    )
+    assert gemini_config.prompt_for_kind.get(Kind.AUDIO) == "Transcribe the audio."
+    assert gemini_config.prompt_for_kind.get(Kind.VIDEO) == "Transcribe the video."
+    assert gemini_config.prompt_for_kind.get(Kind.IMAGE) == "Describe the image."
+
+
 def test_extractor_config_valid(valid_extractor_config):
     assert valid_extractor_config.name == "Test Extractor Config"
     assert valid_extractor_config.extractor_type == ExtractorType.gemini
@@ -88,7 +106,88 @@ def test_extractor_config_invalid_prompt_for_kind(valid_extractor_config):
         }
 
 
+def test_extractor_config_incomplete_prompt_for_kind(valid_extractor_config):
+    with pytest.raises(
+        ValueError,
+        match="Prompt for kind image is required.",
+    ):
+        valid_extractor_config.properties = {
+            "prompt_for_kind": {
+                "document": "Transcribe the document.",
+                "audio": "Transcribe the audio.",
+                "video": "Transcribe the video.",
+                # missing image
+            },
+            "model_name": "gemini-2.0-flash",
+        }
+
+
 def test_extractor_config_invalid_config_type(valid_extractor_config):
     # Create an invalid config type using string
     with pytest.raises(ValueError):
         valid_extractor_config.extractor_type = "invalid_type"
+
+
+def test_format_properties_errors():
+    class SomeModel(BaseModel):
+        name: str = Field(description="The name of the user.")
+        city: str = Field(description="The city of the user.")
+        age: int = Field(description="The age of the user.")
+
+        @model_validator(mode="after")
+        def validate_city(self) -> Self:
+            if self.city == "New York City":
+                raise ValueError("Cannot be New York City")
+            return self
+
+    # errors raised from inside a custom validator
+    try:
+        SomeModel.model_validate(
+            {
+                "name": "John",
+                "city": "New York City",
+                "age": 30,
+            }
+        )
+    except ValidationError as e:
+        s = format_properties_errors(e)
+        assert s == "Value error, Cannot be New York City."
+
+    # missing required field
+    try:
+        SomeModel.model_validate(
+            {
+                "name": "John",
+                "age": 30,
+            }
+        )
+    except ValidationError as e:
+        s = format_properties_errors(e)
+        assert s == "city: Field required."
+
+    # invalid type
+    try:
+        SomeModel.model_validate(
+            {
+                "name": "John",
+                "city": "Pittsburgh",
+                "age": "30",
+            }
+        )  # type: ignore
+    except ValidationError as e:
+        s = format_properties_errors(e)
+        assert (
+            s
+            == "age: Input should be a valid integer, unable to parse string as an integer."
+        )
+
+    # multiple errors
+    try:
+        SomeModel.model_validate(
+            {
+                "name": "John",
+            }
+        )
+    except ValidationError as e:
+        s = format_properties_errors(e)
+        assert s == "city: Field required.\nage: Field required."

From c3dbfd5d5f69a5eb4201f3bfa762adb59e6babf5 Mon Sep 17 00:00:00 2001
From: "Leonard Q. Marcq" <marcqleonard@gmail.com>
Date: Fri, 16 May 2025 03:06:37 +0800
Subject: [PATCH 04/11] test: move passthrough validation tests to model tests

---
 .../extraction/test_base_extractor.py         | 39 -------------------
 .../datamodel/test_extraction_model.py        | 35 +++++++++++++++++
 2 files changed, 35 insertions(+), 39 deletions(-)

diff --git a/libs/core/kiln_ai/adapters/extraction/test_base_extractor.py b/libs/core/kiln_ai/adapters/extraction/test_base_extractor.py
index 1767bdf7..a8e047b4 100644
--- a/libs/core/kiln_ai/adapters/extraction/test_base_extractor.py
+++ b/libs/core/kiln_ai/adapters/extraction/test_base_extractor.py
@@ -206,45 +206,6 @@ def test_extract_non_passthrough(
         assert result.content_format == output_format
 
 
-@pytest.mark.parametrize(
-    "passthrough_mimetypes",
-    [
-        [OutputFormat.TEXT],
-        [OutputFormat.MARKDOWN],
-        [OutputFormat.TEXT, OutputFormat.MARKDOWN],
-    ],
-)
-def test_validate_passthrough_mime_types(
-    mock_gemini_properties, passthrough_mimetypes: list[OutputFormat]
-):
-    config = ExtractorConfig(
-        name="mock",
-        passthrough_mimetypes=passthrough_mimetypes,
-        properties=mock_gemini_properties,
-    )
-    assert config.passthrough_mimetypes == passthrough_mimetypes
-
-
-@pytest.mark.parametrize(
-    "passthrough_mimetypes",
-    [
-        ["image/png"],
-        ["image/png", "text/markdown"],
-        ["audio/mpeg"],
-        ["video/mp4"],
-    ],
-)
-def test_validate_passthrough_mime_types_failure(
-    mock_gemini_properties, passthrough_mimetypes: list[OutputFormat]
-):
-    with pytest.raises(ValueError):
-        ExtractorConfig(
-            name="mock",
-            passthrough_mimetypes=passthrough_mimetypes,
-            properties=mock_gemini_properties,
-        )
-
-
 def test_default_output_format(mock_gemini_properties):
     config = ExtractorConfig(
         name="mock",
diff --git a/libs/core/kiln_ai/datamodel/test_extraction_model.py b/libs/core/kiln_ai/datamodel/test_extraction_model.py
index 2e1fb445..1fc2476f 100644
--- a/libs/core/kiln_ai/datamodel/test_extraction_model.py
+++ b/libs/core/kiln_ai/datamodel/test_extraction_model.py
@@ -6,6 +6,7 @@
     ExtractorConfig,
     ExtractorType,
     Kind,
+    OutputFormat,
     format_properties_errors,
 )
 
@@ -191,3 +192,37 @@ def validate_city(self) -> Self:
     except ValidationError as e:
         s = format_properties_errors(e)
         assert s == "city: Field required.\nage: Field required."
+
+
+@pytest.mark.parametrize(
+    "passthrough_mimetypes",
+    [
+        [OutputFormat.TEXT],
+        [OutputFormat.MARKDOWN],
+        [OutputFormat.TEXT, OutputFormat.MARKDOWN],
+    ],
+)
+def test_valid_passthrough_mimetypes(
+    valid_extractor_config_data, passthrough_mimetypes
+):
+    config_data = valid_extractor_config_data.copy()
+    config_data["passthrough_mimetypes"] = passthrough_mimetypes
+    config = ExtractorConfig(**config_data)
+    assert config.passthrough_mimetypes == passthrough_mimetypes
+
+
+@pytest.mark.parametrize(
+    "passthrough_mimetypes",
+    [
+        ["invalid_format"],
+        ["another_invalid"],
+        [OutputFormat.TEXT, "invalid_format"],
+    ],
+)
+def test_invalid_passthrough_mimetypes(
+    valid_extractor_config_data, passthrough_mimetypes
+):
+    config_data = valid_extractor_config_data.copy()
+    config_data["passthrough_mimetypes"] = passthrough_mimetypes
+    with pytest.raises(ValueError):
+        ExtractorConfig(**config_data)

From 341b22c1308581d0aaab6499d676b8e51a58ff93 Mon Sep 17 00:00:00 2001
From: "Leonard Q. Marcq" <marcqleonard@gmail.com>
Date: Sat, 17 May 2025 01:18:44 +0800
Subject: [PATCH 05/11] refactor: remove pydantic model to validate gemini
 properties and do manually for consistency

---
 .../adapters/extraction/gemini_extractor.py   |  17 +-
 libs/core/kiln_ai/datamodel/extraction.py     |  73 ++++----
 .../datamodel/test_extraction_model.py        | 168 +++++++++---------
 3 files changed, 138 insertions(+), 120 deletions(-)

diff --git a/libs/core/kiln_ai/adapters/extraction/gemini_extractor.py b/libs/core/kiln_ai/adapters/extraction/gemini_extractor.py
index e13c4478..56800ddc 100644
--- a/libs/core/kiln_ai/adapters/extraction/gemini_extractor.py
+++ b/libs/core/kiln_ai/adapters/extraction/gemini_extractor.py
@@ -68,9 +68,20 @@ def __init__(self, gemini_client: genai.Client, extractor_config: ExtractorConfi
                 f"GeminiExtractor must be initialized with a gemini extractor_type config. Got {extractor_config.extractor_type}"
             )
 
+        model_name = extractor_config.model_name()
+        if model_name is None:
+            raise ValueError("properties.model_name is required for GeminiExtractor")
+
+        prompt_for_kind = extractor_config.prompt_for_kind()
+        if prompt_for_kind is None:
+            raise ValueError(
+                "properties.prompt_for_kind is required for GeminiExtractor"
+            )
+
         super().__init__(extractor_config)
         self.gemini_client = gemini_client
-        self.gemini_config = extractor_config.gemini_properties()
+        self.model_name = model_name
+        self.prompt_for_kind = prompt_for_kind
 
     def _get_kind_from_mime_type(self, mime_type: str) -> Kind | None:
         for kind, mime_types in MIME_TYPES_SUPPORTED.items():
@@ -83,12 +94,12 @@ def _extract(self, file_info: FileInfoInternal) -> ExtractionOutput:
         if kind is None:
             raise ValueError(f"Unsupported MIME type: {file_info.mime_type}")
 
-        prompt = self.gemini_config.prompt_for_kind.get(kind)
+        prompt = self.prompt_for_kind.get(kind)
         if prompt is None:
             raise ValueError(f"No prompt found for kind: {kind}")
 
         response = self.gemini_client.models.generate_content(
-            model=self.gemini_config.model_name,
+            model=self.model_name,
             contents=[
                 types.Part.from_bytes(
                     data=pathlib.Path(file_info.path).read_bytes(),
diff --git a/libs/core/kiln_ai/datamodel/extraction.py b/libs/core/kiln_ai/datamodel/extraction.py
index fdff96dd..644de47c 100644
--- a/libs/core/kiln_ai/datamodel/extraction.py
+++ b/libs/core/kiln_ai/datamodel/extraction.py
@@ -1,26 +1,13 @@
 import json
 from enum import Enum
-from typing import Any, List
+from typing import Any
 
-from pydantic import BaseModel, Field, ValidationError, model_validator
+from pydantic import Field, model_validator
 from typing_extensions import Self
 
 from kiln_ai.datamodel.basemodel import NAME_FIELD, KilnBaseModel
 
 
-def format_properties_errors(e: ValidationError) -> str:
-    errors: List[str] = []
-    for error in e.errors():
-        if "loc" in error and len(error["loc"]) > 0:
-            loc = error["loc"][0]
-            msg = error["msg"]
-            errors.append(f"{loc}: {msg}.")
-        else:
-            # ValueError raised from custom validator does not have a loc
-            errors.append(f"{error['msg']}.")
-    return "\n".join(errors)
-
-
 class OutputFormat(str, Enum):
     TEXT = "text/plain"
     MARKDOWN = "text/markdown"
@@ -37,21 +24,33 @@ class Kind(str, Enum):
     AUDIO = "audio"
 
 
-class GeminiProperties(BaseModel):
-    prompt_for_kind: dict[Kind, str] = Field(
-        description="A dictionary of prompts for each kind of content to extract.",
-    )
-
-    model_name: str = Field(
-        description="The name of the model to use for this extractor config. ",
-    )
-
-    @model_validator(mode="after")
-    def validate_model_name(self) -> Self:
-        for kind in Kind:
-            if kind not in self.prompt_for_kind:
-                raise ValueError(f"Prompt for kind {kind.value} is required.")
-        return self
+def validate_prompt_for_kind(prompt_for_kind: Any):
+    # check prompt_for_kind is a dictionary
+    if not isinstance(prompt_for_kind, dict):
+        raise ValueError("prompt_for_kind must be a dictionary.")
+    # check all keys are valid kinds
+    for key, value in prompt_for_kind.items():
+        # type the key to a kind
+        Kind(key)
+        # if not isinstance(typed_key, Kind):
+        #     raise ValueError(f"Invalid kind in prompt_for_kind: {key}")
+        if not isinstance(value, str):
+            raise ValueError(
+                f"Invalid prompt for kind: {key}. Prompt must be a string."
+            )
+    # check all kinds are present
+    for kind in Kind:
+        if kind not in prompt_for_kind:
+            raise ValueError(
+                f"Missing prompt for kind: {kind.value}. All kinds must be present in prompt_for_kind."
+            )
+
+
+def validate_model_name(model_name: Any):
+    if not isinstance(model_name, str):
+        raise ValueError("model_name must be a string.")
+    if model_name == "":
+        raise ValueError("model_name cannot be empty.")
 
 
 class ExtractorConfig(KilnBaseModel):
@@ -77,11 +76,8 @@ class ExtractorConfig(KilnBaseModel):
     @model_validator(mode="after")
     def validate_properties(self) -> Self:
         if self.extractor_type == ExtractorType.gemini:
-            # This will raise an error if the properties are invalid
-            try:
-                GeminiProperties(**self.properties)
-            except ValidationError as e:
-                raise ValueError(format_properties_errors(e))
+            validate_prompt_for_kind(self.properties.get("prompt_for_kind"))
+            validate_model_name(self.properties.get("model_name"))
             return self
         else:
             raise ValueError(f"Invalid extractor type: {self.extractor_type}")
@@ -95,5 +91,8 @@ def validate_json_serializable(self) -> Self:
             raise ValueError(f"Properties must be JSON serializable: {str(e)}")
         return self
 
-    def gemini_properties(self) -> GeminiProperties:
-        return GeminiProperties(**self.properties)
+    def model_name(self) -> str | None:
+        return self.properties.get("model_name")
+
+    def prompt_for_kind(self) -> dict[Kind, str] | None:
+        return self.properties.get("prompt_for_kind")
diff --git a/libs/core/kiln_ai/datamodel/test_extraction_model.py b/libs/core/kiln_ai/datamodel/test_extraction_model.py
index 1fc2476f..2683c6b0 100644
--- a/libs/core/kiln_ai/datamodel/test_extraction_model.py
+++ b/libs/core/kiln_ai/datamodel/test_extraction_model.py
@@ -1,13 +1,12 @@
 import pytest
-from pydantic import BaseModel, Field, ValidationError, model_validator
-from typing_extensions import Self
 
 from kiln_ai.datamodel.extraction import (
     ExtractorConfig,
     ExtractorType,
     Kind,
     OutputFormat,
-    format_properties_errors,
+    validate_model_name,
+    validate_prompt_for_kind,
 )
 
 
@@ -35,13 +34,11 @@ def valid_extractor_config(valid_extractor_config_data):
 
 def test_extractor_config_kind_coercion(valid_extractor_config):
     # check that the string values are coerced to the correct kind
-    gemini_config = valid_extractor_config.gemini_properties()
-    assert (
-        gemini_config.prompt_for_kind.get(Kind.DOCUMENT) == "Transcribe the document."
-    )
-    assert gemini_config.prompt_for_kind.get(Kind.AUDIO) == "Transcribe the audio."
-    assert gemini_config.prompt_for_kind.get(Kind.VIDEO) == "Transcribe the video."
-    assert gemini_config.prompt_for_kind.get(Kind.IMAGE) == "Describe the image."
+    prompt_for_kind = valid_extractor_config.prompt_for_kind()
+    assert prompt_for_kind.get(Kind.DOCUMENT) == "Transcribe the document."
+    assert prompt_for_kind.get(Kind.AUDIO) == "Transcribe the audio."
+    assert prompt_for_kind.get(Kind.VIDEO) == "Transcribe the video."
+    assert prompt_for_kind.get(Kind.IMAGE) == "Describe the image."
 
 
 def test_extractor_config_valid(valid_extractor_config):
@@ -57,14 +54,14 @@ def test_extractor_config_valid(valid_extractor_config):
 
 
 def test_extractor_config_empty_properties(valid_extractor_config):
-    with pytest.raises(ValueError, match="prompt_for_kind: Field required."):
+    with pytest.raises(ValueError, match="prompt_for_kind must be a dictionary"):
         valid_extractor_config.properties = {}
 
 
 def test_extractor_config_missing_model_name(
     valid_extractor_config, valid_extractor_config_data
 ):
-    with pytest.raises(ValueError, match="model_name: Field required."):
+    with pytest.raises(ValueError, match="model_name must be a string"):
         valid_extractor_config.properties = {
             "prompt_for_kind": valid_extractor_config_data["properties"][
                 "prompt_for_kind"
@@ -72,10 +69,22 @@ def test_extractor_config_missing_model_name(
         }
 
 
+def test_extractor_config_empty_model_name(
+    valid_extractor_config, valid_extractor_config_data
+):
+    with pytest.raises(ValueError, match="model_name cannot be empty"):
+        valid_extractor_config.properties = {
+            "prompt_for_kind": valid_extractor_config_data["properties"][
+                "prompt_for_kind"
+            ],
+            "model_name": "",
+        }
+
+
 def test_extractor_config_missing_prompt_for_kind(valid_extractor_config):
     with pytest.raises(
         ValueError,
-        match="prompt_for_kind: Field required.",
+        match="prompt_for_kind must be a dictionary",
     ):
         valid_extractor_config.properties = {"model_name": "gemini-2.0-flash"}
 
@@ -99,7 +108,7 @@ class InvalidClass:
 def test_extractor_config_invalid_prompt_for_kind(valid_extractor_config):
     with pytest.raises(
         ValueError,
-        match="prompt_for_kind: Input should be a valid dictionary.",
+        match="prompt_for_kind must be a dictionary",
     ):
         valid_extractor_config.properties = {
             "prompt_for_kind": "not a dict",
@@ -110,7 +119,7 @@ def test_extractor_config_invalid_prompt_for_kind(valid_extractor_config):
 def test_extractor_config_incomplete_prompt_for_kind(valid_extractor_config):
     with pytest.raises(
         ValueError,
-        match="Prompt for kind image is required.",
+        match="Missing prompt for kind: image",
     ):
         valid_extractor_config.properties = {
             "prompt_for_kind": {
@@ -129,71 +138,6 @@ def test_extractor_config_invalid_config_type(valid_extractor_config):
         valid_extractor_config.extractor_type = "invalid_type"
 
 
-def test_format_properties_errors():
-    class SomeModel(BaseModel):
-        name: str = Field(description="The name of the user.")
-        city: str = Field(description="The city of the user.")
-        age: int = Field(description="The age of the user.")
-
-        @model_validator(mode="after")
-        def validate_city(self) -> Self:
-            if self.city == "New York City":
-                raise ValueError("Cannot be New York City")
-            return self
-
-    # errors raised from inside a custom validator
-    try:
-        SomeModel.model_validate(
-            {
-                "name": "John",
-                "city": "New York City",
-                "age": 30,
-            }
-        )
-    except ValidationError as e:
-        s = format_properties_errors(e)
-        assert s == "Value error, Cannot be New York City."
-
-    # missing required field
-    try:
-        SomeModel.model_validate(
-            {
-                "name": "John",
-                "age": 30,
-            }
-        )
-    except ValidationError as e:
-        s = format_properties_errors(e)
-        assert s == "city: Field required."
-
-    # invalid type
-    try:
-        SomeModel.model_validate(
-            {
-                "name": "John",
-                "city": "Pittsburgh",
-                "age": "30",
-            }
-        )  # type: ignore
-    except ValidationError as e:
-        s = format_properties_errors(e)
-        assert (
-            s
-            == "age: Input should be a valid integer, unable to parse string as an integer."
-        )
-
-    # multiple errors
-    try:
-        SomeModel.model_validate(
-            {
-                "name": "John",
-            }
-        )
-    except ValidationError as e:
-        s = format_properties_errors(e)
-        assert s == "city: Field required.\nage: Field required."
-
-
 @pytest.mark.parametrize(
     "passthrough_mimetypes",
     [
@@ -226,3 +170,67 @@ def test_invalid_passthrough_mimetypes(
     config_data["passthrough_mimetypes"] = passthrough_mimetypes
     with pytest.raises(ValueError):
         ExtractorConfig(**config_data)
+
+
+def test_validate_prompt_for_kind_valid():
+    # check should not raise an error
+    validate_prompt_for_kind(
+        {
+            "document": "string",
+            "audio": "string",
+            "video": "string",
+            "image": "string",
+        }
+    )
+
+
+@pytest.mark.parametrize(
+    "prompt_for_kind, expected_error_message",
+    [
+        ("not a dict", "prompt_for_kind must be a dictionary"),
+        ({"invalid_kind": "not a prompt"}, "'invalid_kind' is not a valid Kind"),
+        (
+            {"document": 123},
+            "Invalid prompt for kind: document. Prompt must be a string.",
+        ),
+        (
+            {
+                "document": "string",
+                "audio": "string",
+                "video": "string",
+                # missing image
+            },
+            "Missing prompt for kind: image",
+        ),
+        (
+            {
+                "document": "string",
+                "audio": "string",
+                "video": "string",
+                "image": "string",
+                "invalid_kind": "string",
+            },
+            "'invalid_kind' is not a valid Kind",
+        ),
+    ],
+)
+def test_validate_prompt_for_kind_errors(prompt_for_kind, expected_error_message):
+    with pytest.raises(ValueError, match=expected_error_message):
+        validate_prompt_for_kind(prompt_for_kind)
+
+
+def test_validate_model_name_valid():
+    # check should not raise an error
+    validate_model_name("gemini-2.0-flash")
+
+
+@pytest.mark.parametrize(
+    "model_name, expected_error_message",
+    [
+        ("", "model_name cannot be empty"),
+        (123, "model_name must be a string"),
+    ],
+)
+def test_validate_model_name_invalid(model_name, expected_error_message):
+    with pytest.raises(ValueError, match=expected_error_message):
+        validate_model_name(model_name)

From 421f4c1b49bd6b44ad87a417d16c924ecc12afef Mon Sep 17 00:00:00 2001
From: "Leonard Q. Marcq" <marcqleonard@gmail.com>
Date: Sat, 24 May 2025 15:21:30 +0800
Subject: [PATCH 06/11] chore: rename adapters/extraction/ into
 adapters/extractors/

---
 libs/core/kiln_ai/adapters/__init__.py                        | 4 ++--
 .../kiln_ai/adapters/{extraction => extractors}/__init__.py   | 0
 .../adapters/{extraction => extractors}/base_extractor.py     | 0
 .../adapters/{extraction => extractors}/gemini_extractor.py   | 2 +-
 .../kiln_ai/adapters/{extraction => extractors}/registry.py   | 4 ++--
 .../{extraction => extractors}/test_base_extractor.py         | 2 +-
 .../{extraction => extractors}/test_gemini_extractor.py       | 4 ++--
 .../adapters/{extraction => extractors}/test_registry.py      | 4 ++--
 8 files changed, 10 insertions(+), 10 deletions(-)
 rename libs/core/kiln_ai/adapters/{extraction => extractors}/__init__.py (100%)
 rename libs/core/kiln_ai/adapters/{extraction => extractors}/base_extractor.py (100%)
 rename libs/core/kiln_ai/adapters/{extraction => extractors}/gemini_extractor.py (98%)
 rename libs/core/kiln_ai/adapters/{extraction => extractors}/registry.py (78%)
 rename libs/core/kiln_ai/adapters/{extraction => extractors}/test_base_extractor.py (99%)
 rename libs/core/kiln_ai/adapters/{extraction => extractors}/test_gemini_extractor.py (98%)
 rename libs/core/kiln_ai/adapters/{extraction => extractors}/test_registry.py (74%)

diff --git a/libs/core/kiln_ai/adapters/__init__.py b/libs/core/kiln_ai/adapters/__init__.py
index 752d1b96..851428dd 100644
--- a/libs/core/kiln_ai/adapters/__init__.py
+++ b/libs/core/kiln_ai/adapters/__init__.py
@@ -19,7 +19,7 @@
 from . import (
     data_gen,
     eval,
-    extraction,
+    extractors,
     fine_tune,
     ml_model_list,
     model_adapters,
@@ -35,5 +35,5 @@
     "prompt_builders",
     "repair",
     "eval",
-    "extraction",
+    "extractors",
 ]
diff --git a/libs/core/kiln_ai/adapters/extraction/__init__.py b/libs/core/kiln_ai/adapters/extractors/__init__.py
similarity index 100%
rename from libs/core/kiln_ai/adapters/extraction/__init__.py
rename to libs/core/kiln_ai/adapters/extractors/__init__.py
diff --git a/libs/core/kiln_ai/adapters/extraction/base_extractor.py b/libs/core/kiln_ai/adapters/extractors/base_extractor.py
similarity index 100%
rename from libs/core/kiln_ai/adapters/extraction/base_extractor.py
rename to libs/core/kiln_ai/adapters/extractors/base_extractor.py
diff --git a/libs/core/kiln_ai/adapters/extraction/gemini_extractor.py b/libs/core/kiln_ai/adapters/extractors/gemini_extractor.py
similarity index 98%
rename from libs/core/kiln_ai/adapters/extraction/gemini_extractor.py
rename to libs/core/kiln_ai/adapters/extractors/gemini_extractor.py
index 56800ddc..bb83d136 100644
--- a/libs/core/kiln_ai/adapters/extraction/gemini_extractor.py
+++ b/libs/core/kiln_ai/adapters/extractors/gemini_extractor.py
@@ -3,7 +3,7 @@
 from google import genai
 from google.genai import types
 
-from kiln_ai.adapters.extraction.base_extractor import (
+from kiln_ai.adapters.extractors.base_extractor import (
     BaseExtractor,
     ExtractionOutput,
     FileInfoInternal,
diff --git a/libs/core/kiln_ai/adapters/extraction/registry.py b/libs/core/kiln_ai/adapters/extractors/registry.py
similarity index 78%
rename from libs/core/kiln_ai/adapters/extraction/registry.py
rename to libs/core/kiln_ai/adapters/extractors/registry.py
index 7d7a52fc..99c445f6 100644
--- a/libs/core/kiln_ai/adapters/extraction/registry.py
+++ b/libs/core/kiln_ai/adapters/extractors/registry.py
@@ -1,5 +1,5 @@
-from kiln_ai.adapters.extraction.base_extractor import BaseExtractor
-from kiln_ai.adapters.extraction.gemini_extractor import GeminiExtractor
+from kiln_ai.adapters.extractors.base_extractor import BaseExtractor
+from kiln_ai.adapters.extractors.gemini_extractor import GeminiExtractor
 from kiln_ai.datamodel.extraction import ExtractorType
 from kiln_ai.utils.exhaustive_error import raise_exhaustive_enum_error
 
diff --git a/libs/core/kiln_ai/adapters/extraction/test_base_extractor.py b/libs/core/kiln_ai/adapters/extractors/test_base_extractor.py
similarity index 99%
rename from libs/core/kiln_ai/adapters/extraction/test_base_extractor.py
rename to libs/core/kiln_ai/adapters/extractors/test_base_extractor.py
index a8e047b4..6d34a574 100644
--- a/libs/core/kiln_ai/adapters/extraction/test_base_extractor.py
+++ b/libs/core/kiln_ai/adapters/extractors/test_base_extractor.py
@@ -3,7 +3,7 @@
 
 import pytest
 
-from kiln_ai.adapters.extraction.base_extractor import (
+from kiln_ai.adapters.extractors.base_extractor import (
     BaseExtractor,
     ExtractionOutput,
     FileInfo,
diff --git a/libs/core/kiln_ai/adapters/extraction/test_gemini_extractor.py b/libs/core/kiln_ai/adapters/extractors/test_gemini_extractor.py
similarity index 98%
rename from libs/core/kiln_ai/adapters/extraction/test_gemini_extractor.py
rename to libs/core/kiln_ai/adapters/extractors/test_gemini_extractor.py
index 42eb9be4..8d1fc533 100644
--- a/libs/core/kiln_ai/adapters/extraction/test_gemini_extractor.py
+++ b/libs/core/kiln_ai/adapters/extractors/test_gemini_extractor.py
@@ -5,13 +5,13 @@
 from google import genai
 from google.genai import types
 
-from kiln_ai.adapters.extraction.base_extractor import (
+from kiln_ai.adapters.extractors.base_extractor import (
     ExtractionOutput,
     FileInfo,
     FileInfoInternal,
     OutputFormat,
 )
-from kiln_ai.adapters.extraction.gemini_extractor import (
+from kiln_ai.adapters.extractors.gemini_extractor import (
     ExtractorConfig,
     GeminiExtractor,
     Kind,
diff --git a/libs/core/kiln_ai/adapters/extraction/test_registry.py b/libs/core/kiln_ai/adapters/extractors/test_registry.py
similarity index 74%
rename from libs/core/kiln_ai/adapters/extraction/test_registry.py
rename to libs/core/kiln_ai/adapters/extractors/test_registry.py
index 5d1d2494..5b53e6d3 100644
--- a/libs/core/kiln_ai/adapters/extraction/test_registry.py
+++ b/libs/core/kiln_ai/adapters/extractors/test_registry.py
@@ -1,7 +1,7 @@
 import pytest
 
-from kiln_ai.adapters.extraction.gemini_extractor import GeminiExtractor
-from kiln_ai.adapters.extraction.registry import extractor_adapter_from_type
+from kiln_ai.adapters.extractors.gemini_extractor import GeminiExtractor
+from kiln_ai.adapters.extractors.registry import extractor_adapter_from_type
 from kiln_ai.datamodel.extraction import ExtractorType
 
 

From c823d5e5a450e1ce6c0355d7d5758468fe0ce261 Mon Sep 17 00:00:00 2001
From: "Leonard Q. Marcq" <marcqleonard@gmail.com>
Date: Sat, 24 May 2025 15:31:36 +0800
Subject: [PATCH 07/11] feat: add optional description on extractor config
 datamodel

---
 libs/core/kiln_ai/datamodel/extraction.py            | 4 +++-
 libs/core/kiln_ai/datamodel/test_extraction_model.py | 9 +++++++++
 2 files changed, 12 insertions(+), 1 deletion(-)

diff --git a/libs/core/kiln_ai/datamodel/extraction.py b/libs/core/kiln_ai/datamodel/extraction.py
index 644de47c..202fb161 100644
--- a/libs/core/kiln_ai/datamodel/extraction.py
+++ b/libs/core/kiln_ai/datamodel/extraction.py
@@ -55,7 +55,9 @@ def validate_model_name(model_name: Any):
 
 class ExtractorConfig(KilnBaseModel):
     name: str = NAME_FIELD
-
+    description: str | None = Field(
+        default=None, description="The description of the extractor config"
+    )
     output_format: OutputFormat = Field(
         default=OutputFormat.MARKDOWN,
         description="The format to use for the output.",
diff --git a/libs/core/kiln_ai/datamodel/test_extraction_model.py b/libs/core/kiln_ai/datamodel/test_extraction_model.py
index 2683c6b0..6c1b2c5c 100644
--- a/libs/core/kiln_ai/datamodel/test_extraction_model.py
+++ b/libs/core/kiln_ai/datamodel/test_extraction_model.py
@@ -14,6 +14,7 @@
 def valid_extractor_config_data():
     return {
         "name": "Test Extractor Config",
+        "description": "Test description",
         "extractor_type": ExtractorType.gemini,
         "properties": {
             "prompt_for_kind": {
@@ -41,8 +42,16 @@ def test_extractor_config_kind_coercion(valid_extractor_config):
     assert prompt_for_kind.get(Kind.IMAGE) == "Describe the image."
 
 
+def test_extractor_config_description_empty(valid_extractor_config_data):
+    # should not raise an error when description is None
+    valid_extractor_config_data["description"] = None
+    valid_extractor_config = ExtractorConfig(**valid_extractor_config_data)
+    assert valid_extractor_config.description is None
+
+
 def test_extractor_config_valid(valid_extractor_config):
     assert valid_extractor_config.name == "Test Extractor Config"
+    assert valid_extractor_config.description == "Test description"
     assert valid_extractor_config.extractor_type == ExtractorType.gemini
     assert valid_extractor_config.properties["prompt_for_kind"] == {
         "document": "Transcribe the document.",

From afb2d08d0e707e41ffc98da85d19c829be5ee6e2 Mon Sep 17 00:00:00 2001
From: "Leonard Q. Marcq" <marcqleonard@gmail.com>
Date: Sat, 24 May 2025 15:34:59 +0800
Subject: [PATCH 08/11] refactor: remove Gemini default extractor type

---
 .../core/kiln_ai/adapters/extractors/test_base_extractor.py | 6 +++++-
 .../kiln_ai/adapters/extractors/test_gemini_extractor.py    | 3 +++
 libs/core/kiln_ai/datamodel/extraction.py                   | 1 -
 3 files changed, 8 insertions(+), 2 deletions(-)

diff --git a/libs/core/kiln_ai/adapters/extractors/test_base_extractor.py b/libs/core/kiln_ai/adapters/extractors/test_base_extractor.py
index 6d34a574..d50630c9 100644
--- a/libs/core/kiln_ai/adapters/extractors/test_base_extractor.py
+++ b/libs/core/kiln_ai/adapters/extractors/test_base_extractor.py
@@ -10,7 +10,7 @@
     FileInfoInternal,
     OutputFormat,
 )
-from kiln_ai.datamodel.extraction import ExtractorConfig
+from kiln_ai.datamodel.extraction import ExtractorConfig, ExtractorType
 
 
 class MockBaseExtractor(BaseExtractor):
@@ -40,6 +40,7 @@ def mock_extractor(mock_gemini_properties):
     return MockBaseExtractor(
         ExtractorConfig(
             name="mock",
+            extractor_type=ExtractorType.gemini,
             output_format=OutputFormat.MARKDOWN,
             properties=mock_gemini_properties,
         )
@@ -54,6 +55,7 @@ def mock_extractor_with_passthroughs(
     return MockBaseExtractor(
         ExtractorConfig(
             name="mock",
+            extractor_type=ExtractorType.gemini,
             passthrough_mimetypes=mimetypes,
             output_format=output_format,
             properties=properties,
@@ -209,6 +211,7 @@ def test_extract_non_passthrough(
 def test_default_output_format(mock_gemini_properties):
     config = ExtractorConfig(
         name="mock",
+        extractor_type=ExtractorType.gemini,
         properties=mock_gemini_properties,
     )
     assert config.output_format == OutputFormat.MARKDOWN
@@ -228,6 +231,7 @@ def test_extract_failure_from_mime_type_guess(mock_gemini_properties):
     extractor = MockBaseExtractor(
         ExtractorConfig(
             name="mock",
+            extractor_type=ExtractorType.gemini,
             properties=mock_gemini_properties,
         )
     )
diff --git a/libs/core/kiln_ai/adapters/extractors/test_gemini_extractor.py b/libs/core/kiln_ai/adapters/extractors/test_gemini_extractor.py
index 8d1fc533..002b271a 100644
--- a/libs/core/kiln_ai/adapters/extractors/test_gemini_extractor.py
+++ b/libs/core/kiln_ai/adapters/extractors/test_gemini_extractor.py
@@ -16,6 +16,7 @@
     GeminiExtractor,
     Kind,
 )
+from kiln_ai.datamodel.extraction import ExtractorType
 from kiln_ai.utils.config import Config
 
 PROMPTS_FOR_KIND: dict[str, str] = {
@@ -37,6 +38,7 @@ def mock_gemini_extractor(mock_gemini_client):
         mock_gemini_client,
         ExtractorConfig(
             name="mock",
+            extractor_type=ExtractorType.gemini,
             properties={
                 "prompt_for_kind": PROMPTS_FOR_KIND,
                 "model_name": "fake-model",
@@ -215,6 +217,7 @@ def paid_gemini_extractor(model_name: str):
     return GeminiExtractor(
         extractor_config=ExtractorConfig(
             name="paid-gemini",
+            extractor_type=ExtractorType.gemini,
             properties={
                 "model_name": model_name,
                 "prompt_for_kind": {
diff --git a/libs/core/kiln_ai/datamodel/extraction.py b/libs/core/kiln_ai/datamodel/extraction.py
index 202fb161..bf1f005f 100644
--- a/libs/core/kiln_ai/datamodel/extraction.py
+++ b/libs/core/kiln_ai/datamodel/extraction.py
@@ -67,7 +67,6 @@ class ExtractorConfig(KilnBaseModel):
         description="If the mimetype is in this list, the extractor will not be used and the text content of the file will be returned as is.",
     )
     extractor_type: ExtractorType = Field(
-        default=ExtractorType.gemini,
         description="This is used to determine the type of extractor to use.",
     )
     properties: dict[str, Any] = Field(

From f42707f17024a49bee7d28efd094c9d4d1538cbc Mon Sep 17 00:00:00 2001
From: "Leonard Q. Marcq" <marcqleonard@gmail.com>
Date: Sat, 24 May 2025 15:36:13 +0800
Subject: [PATCH 09/11] fix: field description incorrectly referencing
 config_type

---
 libs/core/kiln_ai/datamodel/extraction.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libs/core/kiln_ai/datamodel/extraction.py b/libs/core/kiln_ai/datamodel/extraction.py
index bf1f005f..3f04bf44 100644
--- a/libs/core/kiln_ai/datamodel/extraction.py
+++ b/libs/core/kiln_ai/datamodel/extraction.py
@@ -71,7 +71,7 @@ class ExtractorConfig(KilnBaseModel):
     )
     properties: dict[str, Any] = Field(
         default={},
-        description="Properties to be used to execute the extractor config. This is config_type specific and should serialize to a json dict.",
+        description="Properties to be used to execute the extractor config. This is extractor_type specific and should serialize to a json dict.",
     )
 
     @model_validator(mode="after")

From 92d5ea184cf94270914d9434d51c44f69255e6a9 Mon Sep 17 00:00:00 2001
From: "Leonard Q. Marcq" <marcqleonard@gmail.com>
Date: Sat, 24 May 2025 16:59:32 +0800
Subject: [PATCH 10/11] refactor: restrict type on properties dict

---
 libs/core/kiln_ai/datamodel/extraction.py      | 18 ++++--------------
 .../kiln_ai/datamodel/test_extraction_model.py |  2 +-
 2 files changed, 5 insertions(+), 15 deletions(-)

diff --git a/libs/core/kiln_ai/datamodel/extraction.py b/libs/core/kiln_ai/datamodel/extraction.py
index 3f04bf44..50e054ed 100644
--- a/libs/core/kiln_ai/datamodel/extraction.py
+++ b/libs/core/kiln_ai/datamodel/extraction.py
@@ -1,6 +1,5 @@
-import json
 from enum import Enum
-from typing import Any
+from typing import Any, cast
 
 from pydantic import Field, model_validator
 from typing_extensions import Self
@@ -69,7 +68,7 @@ class ExtractorConfig(KilnBaseModel):
     extractor_type: ExtractorType = Field(
         description="This is used to determine the type of extractor to use.",
     )
-    properties: dict[str, Any] = Field(
+    properties: dict[str, str | int | float | bool | dict[str, str]] = Field(
         default={},
         description="Properties to be used to execute the extractor config. This is extractor_type specific and should serialize to a json dict.",
     )
@@ -83,17 +82,8 @@ def validate_properties(self) -> Self:
         else:
             raise ValueError(f"Invalid extractor type: {self.extractor_type}")
 
-    @model_validator(mode="after")
-    def validate_json_serializable(self) -> Self:
-        try:
-            # This will raise a TypeError if the dict contains non-JSON-serializable objects
-            json.dumps(self.properties)
-        except TypeError as e:
-            raise ValueError(f"Properties must be JSON serializable: {str(e)}")
-        return self
-
     def model_name(self) -> str | None:
-        return self.properties.get("model_name")
+        return cast(str, self.properties.get("model_name"))
 
     def prompt_for_kind(self) -> dict[Kind, str] | None:
-        return self.properties.get("prompt_for_kind")
+        return cast(dict[Kind, str], self.properties.get("prompt_for_kind"))
diff --git a/libs/core/kiln_ai/datamodel/test_extraction_model.py b/libs/core/kiln_ai/datamodel/test_extraction_model.py
index 6c1b2c5c..fe77cb1a 100644
--- a/libs/core/kiln_ai/datamodel/test_extraction_model.py
+++ b/libs/core/kiln_ai/datamodel/test_extraction_model.py
@@ -104,7 +104,7 @@ def test_extractor_config_invalid_json(
     class InvalidClass:
         pass
 
-    with pytest.raises(ValueError, match="Properties must be JSON serializable"):
+    with pytest.raises(ValueError, match="validation errors for ExtractorConfig"):
         valid_extractor_config.properties = {
             "prompt_for_kind": valid_extractor_config_data["properties"][
                 "prompt_for_kind"

From 6e4820f89957aaffd819bdb1856f16e66335e44a Mon Sep 17 00:00:00 2001
From: "Leonard Q. Marcq" <marcqleonard@gmail.com>
Date: Sat, 24 May 2025 17:29:01 +0800
Subject: [PATCH 11/11] fix: commented out line, and improve error messages

---
 libs/core/kiln_ai/datamodel/extraction.py           | 13 ++++++++-----
 .../core/kiln_ai/datamodel/test_extraction_model.py | 13 ++++++++-----
 2 files changed, 16 insertions(+), 10 deletions(-)

diff --git a/libs/core/kiln_ai/datamodel/extraction.py b/libs/core/kiln_ai/datamodel/extraction.py
index 50e054ed..86083510 100644
--- a/libs/core/kiln_ai/datamodel/extraction.py
+++ b/libs/core/kiln_ai/datamodel/extraction.py
@@ -29,19 +29,22 @@ def validate_prompt_for_kind(prompt_for_kind: Any):
         raise ValueError("prompt_for_kind must be a dictionary.")
     # check all keys are valid kinds
     for key, value in prompt_for_kind.items():
+        # raise an error if the key is not a valid kind
+        try:
+            Kind(key)
+        except ValueError:
+            raise ValueError(f"Invalid kind in prompt_for_kind: '{key}'")
         # type the key to a kind
-        Kind(key)
-        # if not isinstance(typed_key, Kind):
-        #     raise ValueError(f"Invalid kind in prompt_for_kind: {key}")
         if not isinstance(value, str):
             raise ValueError(
-                f"Invalid prompt for kind: {key}. Prompt must be a string."
+                f"Invalid prompt for kind: '{key}'. Prompt must be a string."
             )
+
     # check all kinds are present
     for kind in Kind:
         if kind not in prompt_for_kind:
             raise ValueError(
-                f"Missing prompt for kind: {kind.value}. All kinds must be present in prompt_for_kind."
+                f"Missing prompt for kind: '{kind.value}'. All kinds must be present in prompt_for_kind."
             )
 
 
diff --git a/libs/core/kiln_ai/datamodel/test_extraction_model.py b/libs/core/kiln_ai/datamodel/test_extraction_model.py
index fe77cb1a..03f05d76 100644
--- a/libs/core/kiln_ai/datamodel/test_extraction_model.py
+++ b/libs/core/kiln_ai/datamodel/test_extraction_model.py
@@ -128,7 +128,7 @@ def test_extractor_config_invalid_prompt_for_kind(valid_extractor_config):
 def test_extractor_config_incomplete_prompt_for_kind(valid_extractor_config):
     with pytest.raises(
         ValueError,
-        match="Missing prompt for kind: image",
+        match="Missing prompt for kind: 'image'",
     ):
         valid_extractor_config.properties = {
             "prompt_for_kind": {
@@ -197,10 +197,13 @@ def test_validate_prompt_for_kind_valid():
     "prompt_for_kind, expected_error_message",
     [
         ("not a dict", "prompt_for_kind must be a dictionary"),
-        ({"invalid_kind": "not a prompt"}, "'invalid_kind' is not a valid Kind"),
+        (
+            {"invalid_kind": "not a prompt"},
+            "Invalid kind in prompt_for_kind: 'invalid_kind'",
+        ),
         (
             {"document": 123},
-            "Invalid prompt for kind: document. Prompt must be a string.",
+            "Invalid prompt for kind: 'document'. Prompt must be a string.",
         ),
         (
             {
@@ -209,7 +212,7 @@ def test_validate_prompt_for_kind_valid():
                 "video": "string",
                 # missing image
             },
-            "Missing prompt for kind: image",
+            "Missing prompt for kind: 'image'",
         ),
         (
             {
@@ -219,7 +222,7 @@ def test_validate_prompt_for_kind_valid():
                 "image": "string",
                 "invalid_kind": "string",
             },
-            "'invalid_kind' is not a valid Kind",
+            "Invalid kind in prompt_for_kind: 'invalid_kind'",
         ),
     ],
 )
